import { readFile } from "node:fs/promises";
import {
    type CSSFileOutput,
    type ColorFallbackStrategy,
    type FluidConfig,
    type SugarcubeConfig,
    clearMatchCache,
    convertConfigToUnoRules,
    fillDefaults,
    findResolverDocument,
    generateCSSVariables,
    processAndConvertTokens,
    writeCSSUtilitiesToDisk,
    writeCSSVariablesToDisk,
} from "@sugarcube-sh/core";
import type {
    InternalConfig,
    ModifierMeta,
    NormalizedConvertedTokens,
    ResolvedTokens,
    TokenTree,
} from "@sugarcube-sh/core";
import { configFileExists, loadInternalConfig } from "@sugarcube-sh/core";
import { type UserConfig, createGenerator } from "@unocss/core";
import { Command } from "commander";
import { relative } from "pathe";
import color from "picocolors";
import { glob } from "tinyglobby";
import packageJson from "../../package.json" with { type: "json" };
import { ERROR_MESSAGES } from "../constants/error-messages.js";
import { isPackageInstalled } from "../detection/is-package-installed.js";
import { loadAndResolveTokensForCLI } from "../pipelines/load-and-resolve-for-cli.js";
import { S_BAR, S_INFO, S_SUCCESS, intro, label, outro } from "../prompts/common.js";
import { log } from "../prompts/log.js";
import { CLIError } from "../types/index.js";
import { handleError } from "../utils/handle-error.js";
import { startWatcher } from "../watch/watcher.js";
import { validateFilename } from "../validation/flags.js";

const CSS_BANNER = `/* Generated by @sugarcube-sh/cli v${packageJson.version} */\n\n`;

const SCAN_INCLUDE_PATTERN =
    "**/*.{html,htm,js,ts,jsx,tsx,vue,svelte,astro,php,njk,liquid,pug,hbs,handlebars,twig,erb,ejs}";

const SCAN_IGNORE_PATTERNS = [
    "**/node_modules/**",
    "**/dist/**",
    "**/build/**",
    "**/.next/**",
    "**/.nuxt/**",
    "**/.astro/**",
    "**/.git/**",
    "**/coverage/**",
    "**/.pnpm/**",
    "**/.pnpm-store/**",
    "**/.npm/**",
    "**/.cache/**",
    "**/.turbo/**",
    "**/.vercel/**",
    "**/.svelte-kit/**",
    "**/out/**",
    "**/__snapshots__/**",
    "**/*.config.{js,ts,mjs}",
    "**/*.min.js",
    "**/*.bundle.js",
    "**/*.d.ts",
];

// Safety limits to prevent OOM crashes
// Can't just search up etc because CLI has to work with the simplest possible setup
// e.g. no git repo, no package.json, no node_modules, no build tools etc.
const MAX_FILES_TO_SCAN = 10_000;
const MAX_TOTAL_SIZE_MB = 100;

export async function generateSugarcubeUtilities(
    tokens: NormalizedConvertedTokens,
    config: InternalConfig
): Promise<CSSFileOutput> {
    if (!config.utilities || Object.keys(config.utilities).length === 0) {
        return [];
    }

    const sugarcubePreset = {
        name: "sugarcube",
        rules: convertConfigToUnoRules(config.utilities, tokens),
        preflights: [],
    };

    const generatorOptions: UserConfig = {
        presets: [sugarcubePreset],
    };

    const generator = await createGenerator(generatorOptions);

    const files = await glob([SCAN_INCLUDE_PATTERN], {
        ignore: SCAN_IGNORE_PATTERNS,
        dot: false,
        onlyFiles: true,
        absolute: false,
    });

    if (files.length === 0) return [];

    if (files.length > MAX_FILES_TO_SCAN) {
        throw new CLIError(
            `Found ${files.length} files to scan (limit: ${MAX_FILES_TO_SCAN}). Are you running this from a monorepo root or a directory containing multiple projects? Run the command from within a single project directory instead.`
        );
    }

    const sources: string[] = [];
    let totalSize = 0;
    const maxSizeBytes = MAX_TOTAL_SIZE_MB * 1024 * 1024;

    for (const file of files) {
        const content = await readFile(file, "utf8");
        totalSize += content.length;

        if (totalSize > maxSizeBytes) {
            throw new CLIError(
                `Total source size exceeds ${MAX_TOTAL_SIZE_MB}MB. Are you running this from a monorepo root or a directory containing multiple projects? Run the command from within a single project directory instead.`
            );
        }

        sources.push(content);
    }

    const combinedSource = sources.join("\n");

    const { css } = await generator.generate(combinedSource, {
        preflights: false,
    });

    if (!css?.trim()) return [];

    return [
        {
            path: `${config.output.utilities}/${config.output.utilitiesFilename}`,
            css,
        },
    ];
}

function addBanner(output: CSSFileOutput): CSSFileOutput {
    return output.map((file) => ({
        ...file,
        css: CSS_BANNER + file.css,
    }));
}

function wrapInLayer(output: CSSFileOutput, layerName: string): CSSFileOutput {
    return output.map((file) => {
        // Need extra formatting for @layer blocks
        const indentedCss = file.css
            .split("\n")
            .map((line) => (line.trim() ? `    ${line}` : line))
            .join("\n");
        return {
            ...file,
            css: `@layer ${layerName} {\n${indentedCss}}\n`,
        };
    });
}

async function generateAllCSS(
    trees: TokenTree[],
    resolved: ResolvedTokens,
    config: InternalConfig,
    modifiers: ModifierMeta[]
): Promise<CSSFileOutput> {
    const output: CSSFileOutput = [];
    const layersConfig = config.output.layers;

    const convertedTokens = await processAndConvertTokens(trees, resolved, config);

    let cssVariables = await generateCSSVariables(convertedTokens, config, modifiers);
    if (layersConfig) {
        cssVariables = wrapInLayer(cssVariables, layersConfig.variables);
    }
    const cssVariablesWithBanner = addBanner(cssVariables);
    await writeCSSVariablesToDisk(cssVariablesWithBanner);
    output.push(...cssVariablesWithBanner);

    let utilities = await generateSugarcubeUtilities(convertedTokens, config);
    if (layersConfig) {
        utilities = wrapInLayer(utilities, layersConfig.utilities);
    }
    const utilitiesWithBanner = addBanner(utilities);
    await writeCSSUtilitiesToDisk(utilitiesWithBanner);
    output.push(...utilitiesWithBanner);

    return output;
}

interface GenerateFlags {
    force?: boolean;
    silent?: boolean;
    watch?: boolean;
    resolver?: string;
    stylesDir?: string;
    variablesDir?: string;
    variablesFilename?: string;
    utilitiesDir?: string;
    utilitiesFilename?: string;
    fluidMin?: string;
    fluidMax?: string;
    colorFallback?: ColorFallbackStrategy;
}

function buildConfigFromFlags(flags: GenerateFlags): InternalConfig {
    let fluidConfig: FluidConfig | undefined;
    if (flags.fluidMin || flags.fluidMax) {
        fluidConfig = {
            min: flags.fluidMin ? Number.parseInt(flags.fluidMin, 10) : 320,
            max: flags.fluidMax ? Number.parseInt(flags.fluidMax, 10) : 1200,
        };
    }

    const userConfig: SugarcubeConfig = {
        resolver: flags.resolver,
        output: {
            cssRoot: flags.stylesDir,
            variables: flags.variablesDir,
            variablesFilename: flags.variablesFilename,
            utilities: flags.utilitiesDir,
            utilitiesFilename: flags.utilitiesFilename,
        },
        transforms: {
            fluid: fluidConfig,
            colorFallbackStrategy: flags.colorFallback,
        },
    };

    return fillDefaults(userConfig);
}

function mergeConfigWithFlags(config: InternalConfig, flags: GenerateFlags): InternalConfig {
    const fluid: FluidConfig = {
        min: flags.fluidMin ? Number.parseInt(flags.fluidMin, 10) : config.transforms.fluid.min,
        max: flags.fluidMax ? Number.parseInt(flags.fluidMax, 10) : config.transforms.fluid.max,
    };

    return {
        ...config,
        resolver: flags.resolver ?? config.resolver,
        transforms: {
            fluid,
            colorFallbackStrategy: flags.colorFallback ?? config.transforms.colorFallbackStrategy,
        },
        output: {
            ...config.output,
            cssRoot: flags.stylesDir ?? config.output.cssRoot,
            variables: flags.variablesDir ?? config.output.variables,
            variablesFilename: flags.variablesFilename ?? config.output.variablesFilename,
            utilities: flags.utilitiesDir ?? config.output.utilities,
            utilitiesFilename: flags.utilitiesFilename ?? config.output.utilitiesFilename,
        },
    };
}

function hasRelevantFlags(flags: GenerateFlags): boolean {
    return !!(
        flags.resolver ||
        flags.stylesDir ||
        flags.variablesDir ||
        flags.variablesFilename ||
        flags.utilitiesDir ||
        flags.utilitiesFilename ||
        flags.fluidMin ||
        flags.fluidMax ||
        flags.colorFallback
    );
}

async function resolveConfig(options: GenerateFlags): Promise<InternalConfig> {
    if (configFileExists()) {
        const { config: loadedConfig } = await loadInternalConfig();
        return mergeConfigWithFlags(loadedConfig, options);
    }

    // Note: We do our own discovery here instead of using loadInternalConfig's fallback
    // because generate needs special flag-merging logic that loadInternalConfig doesn't handle.
    const discovery = await findResolverDocument(process.cwd());

    if (discovery.found === "multiple") {
        throw new CLIError(ERROR_MESSAGES.GENERATE_MULTIPLE_RESOLVERS_NO_CONFIG(discovery.paths));
    }

    const resolverPath =
        options.resolver ?? (discovery.found === "one" ? discovery.path : undefined);

    if (resolverPath || hasRelevantFlags(options)) {
        return buildConfigFromFlags({
            ...options,
            resolver: resolverPath,
        });
    }

    throw new CLIError(ERROR_MESSAGES.GENERATE_NO_CONFIG_OR_RESOLVER());
}

export const generate = new Command()
    .name("generate")
    .description("Generate CSS from your design tokens")
    .option("--force", "Skip overwrite confirmation")
    .option("-s, --silent", "Suppress logs and prompts")
    .option("-w, --watch", "Watch for changes and regenerate automatically")
    .option("--resolver <path>", "Path to token resolver file (.resolver.json)")
    .option("--styles-dir <dir>", "CSS output directory (default: 'src/styles')")
    .option(
        "--variables-dir <dir>",
        "Token variables output directory (default: 'src/styles/global')"
    )
    .option(
        "--variables-filename <name>",
        "Token variables filename (default: 'tokens.variables.gen.css')"
    )
    .option("--utilities-dir <dir>", "Utilities output directory (default: 'src/styles/utilities')")
    .option("--utilities-filename <name>", "Utilities filename (default: 'utilities.gen.css')")
    .option("--fluid-min <number>", "Minimum viewport width for fluid scaling (default: 320)")
    .option("--fluid-max <number>", "Maximum viewport width for fluid scaling (default: 1200)")
    .option(
        "--color-fallback <strategy>",
        "Color fallback strategy: 'native' or 'polyfill' (default: native)"
    )
    .action(async (options: GenerateFlags) => {
        try {
            if (!options.silent) {
                intro(label("Generate CSS"));
            }

            validateFlags(options);

            // Check if Vite plugin is installed and warn/exit
            if (isPackageInstalled("@sugarcube-sh/vite")) {
                throw new CLIError(
                    "Sugarcube vite plugin detected. When using the plugin, CSS is generated automatically during your build process. Remove the plugin to use CLI generation instead."
                );
            }

            const finalConfig = await resolveConfig(options);

            if (options.watch) {
                await runWatchMode(finalConfig, options);
            } else {
                await runOneTimeGeneration(finalConfig, options);
            }
        } catch (error) {
            handleError(error);
        }
    });

/**
 * Run a single generation cycle and return the output files.
 */
async function runGeneration(config: InternalConfig): Promise<CSSFileOutput> {
    // Clear the match cache to ensure we pick up any new tokens
    clearMatchCache();

    const { trees, resolved, modifiers } = await loadAndResolveTokensForCLI(config);
    return generateAllCSS(trees, resolved, config, modifiers);
}

/**
 * Run a one-time generation with full output.
 */
async function runOneTimeGeneration(config: InternalConfig, options: GenerateFlags): Promise<void> {
    if (!options.silent) {
        intro(label("Generate CSS"));
    }

    const output = await runGeneration(config);

    if (!options.silent) {
        const allFiles = output.map((f) => f.path);
        const uniqueFiles = [...new Set(allFiles)];
        const relativePaths = uniqueFiles.map((file) => relative(process.cwd(), file));

        const tasks = relativePaths.map((file) => ({
            pending: `Write ${file}`,
            start: `Writing ${file}`,
            end: `Wrote ${file}`,
            while: async () => {},
        }));

        await log.tasks(tasks, {
            spacing: 1,
            minDurationMs: 0,
            successPauseMs: 100,
            successMessage: "ðŸŽ‰ Files written!",
        });

        log.space(1);
        outro(color.green("CSS generated successfully."));
    }
}

/**
 * Run watch mode - generate once, then watch for changes.
 */
async function runWatchMode(config: InternalConfig, options: GenerateFlags): Promise<void> {
    // Initial generation
    const startTime = performance.now();
    const output = await runGeneration(config);
    const duration = Math.round(performance.now() - startTime);

    // Print watch mode header
    process.stdout.write(`\n${color.green(S_SUCCESS)}  Watch mode started\n`);
    process.stdout.write(`${color.gray(S_BAR)}\n`);

    // Print initial generation result
    const allFiles = output.map((f) => f.path);
    const uniqueFiles = [...new Set(allFiles)];
    const relativePaths = uniqueFiles.map((file) => relative(process.cwd(), file));

    process.stdout.write(`${color.green(S_SUCCESS)}  Generated in ${duration}ms\n`);
    for (const file of relativePaths) {
        process.stdout.write(`${color.gray(S_BAR)}     ${color.dim("â†’")} ${file}\n`);
    }
    process.stdout.write(`${color.gray(S_BAR)}\n`);

    // Start the watcher
    const watcher = await startWatcher(config, {
        onRegenerate: async (changedPath: string) => {
            const regenStart = performance.now();
            const regenOutput = await runGeneration(config);
            const regenDuration = Math.round(performance.now() - regenStart);

            const changedRelative = relative(process.cwd(), changedPath);
            process.stdout.write(`${color.blue(S_INFO)}  Change detected: ${changedRelative}\n`);

            const regenFiles = regenOutput.map((f) => f.path);
            const regenUniqueFiles = [...new Set(regenFiles)];
            const regenRelativePaths = regenUniqueFiles.map((file) =>
                relative(process.cwd(), file)
            );

            process.stdout.write(`${color.green(S_SUCCESS)}  Regenerated in ${regenDuration}ms\n`);
            for (const file of regenRelativePaths) {
                process.stdout.write(`${color.gray(S_BAR)}     ${color.dim("â†’")} ${file}\n`);
            }
            process.stdout.write(`${color.gray(S_BAR)}\n`);
        },
        onError: (error: Error) => {
            log.error(error.message);
            process.stdout.write(`${color.gray(S_BAR)}\n`);
        },
        onReady: (tokenFileCount: number) => {
            process.stdout.write(
                `${color.gray(S_BAR)}  Watching ${tokenFileCount} token file${tokenFileCount === 1 ? "" : "s"}\n`
            );
            process.stdout.write(`${color.gray(S_BAR)}  Scanning markup files for utilities\n`);
            process.stdout.write(`${color.gray(S_BAR)}\n`);
            process.stdout.write(`${color.gray(S_BAR)}  Press ${color.cyan("Ctrl+C")} to stop\n`);
            process.stdout.write(`${color.gray(S_BAR)}\n`);
        },
    });

    // Handle graceful shutdown
    const cleanup = async () => {
        // Use console.log for synchronous output before exit
        console.log(`\n${color.gray(S_BAR)}`);
        console.log(`${color.gray(S_BAR)}  Stopping watch mode...`);
        await watcher.close();
        process.exit(0);
    };

    process.on("SIGINT", cleanup);
    process.on("SIGTERM", cleanup);

    // Keep the process running
    await new Promise(() => {});
}
