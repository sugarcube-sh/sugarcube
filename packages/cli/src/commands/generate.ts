import { readFile } from "node:fs/promises";
import {
    type CSSFileOutput,
    type ColorFallbackStrategy,
    type FluidConfig,
    type SugarcubeConfig,
    convertConfigToUnoRules,
    fillDefaults,
    findResolverDocument,
    generateCSSVariables,
    processAndConvertTokens,
    writeCSSUtilitiesToDisk,
    writeCSSVariablesToDisk,
} from "@sugarcube-sh/core";
import type {
    InternalConfig,
    ModifierMeta,
    NormalizedConvertedTokens,
    ResolvedTokens,
    TokenTree,
} from "@sugarcube-sh/core";
import { configFileExists, loadInternalConfig } from "@sugarcube-sh/core";
import { createGenerator } from "@unocss/core";
import { Command } from "commander";
import { glob } from "tinyglobby";
import { relative } from "pathe";
import color from "picocolors";
import packageJson from "../../package.json" with { type: "json" };
import { ERROR_MESSAGES } from "../constants/error-messages.js";
import { isPackageInstalled } from "../detection/is-package-installed.js";
import { loadAndResolveTokensForCLI } from "../pipelines/load-and-resolve-for-cli.js";
import { intro, label, outro } from "../prompts/common.js";
import { log } from "../prompts/log.js";
import { CLIError } from "../types/index.js";
import { handleError } from "../utils/handle-error.js";

const CSS_BANNER = `/* Generated by @sugarcube-sh/cli v${packageJson.version} */\n\n`;

const SCAN_INCLUDE_PATTERN =
    "**/*.{html,htm,js,ts,jsx,tsx,vue,svelte,astro,php,njk,liquid,pug,hbs,handlebars,twig,erb,ejs}";

const SCAN_IGNORE_PATTERNS = [
    "**/node_modules/**",
    "**/dist/**",
    "**/build/**",
    "**/.next/**",
    "**/.nuxt/**",
    "**/.astro/**",
    "**/.git/**",
    "**/coverage/**",
    "**/.pnpm/**",
    "**/.pnpm-store/**",
    "**/.npm/**",
    "**/.cache/**",
    "**/.turbo/**",
    "**/.vercel/**",
    "**/.svelte-kit/**",
    "**/out/**",
    "**/__snapshots__/**",
    "**/*.config.{js,ts,mjs}",
    "**/*.min.js",
    "**/*.bundle.js",
    "**/*.d.ts",
];

// Safety limits to prevent OOM crashes
// Can't just search up etc because CLI has to work with the simplest possible setup
// e.g. no git repo, no package.json, no node_modules, no build tools etc.
const MAX_FILES_TO_SCAN = 10_000;
const MAX_TOTAL_SIZE_MB = 100;

export async function generateSugarcubeUtilities(
    tokens: NormalizedConvertedTokens,
    config: InternalConfig
): Promise<CSSFileOutput> {
    const sugarcubePreset = {
        name: "sugarcube",
        rules: convertConfigToUnoRules(config.utilities ?? {}, tokens),
        preflights: [],
    };

    const generator = await createGenerator({
        presets: [sugarcubePreset],
    });

    const files = await glob([SCAN_INCLUDE_PATTERN], {
        ignore: SCAN_IGNORE_PATTERNS,
        dot: false,
        onlyFiles: true,
        absolute: false,
    });

    if (files.length === 0) return [];

    if (files.length > MAX_FILES_TO_SCAN) {
        throw new CLIError(
            `Found ${files.length} files to scan (limit: ${MAX_FILES_TO_SCAN}). Are you running this from a monorepo root or a directory containing multiple projects? Run the command from within a single project directory instead.`
        );
    }

    const sources: string[] = [];
    let totalSize = 0;
    const maxSizeBytes = MAX_TOTAL_SIZE_MB * 1024 * 1024;

    for (const file of files) {
        const content = await readFile(file, "utf8");
        totalSize += content.length;

        if (totalSize > maxSizeBytes) {
            throw new CLIError(
                `Total source size exceeds ${MAX_TOTAL_SIZE_MB}MB. Are you running this from a monorepo root or a directory containing multiple projects? Run the command from within a single project directory instead.`
            );
        }

        sources.push(content);
    }

    const combinedSource = sources.join("\n");

    const { css } = await generator.generate(combinedSource, {
        preflights: false,
    });

    if (!css?.trim()) return [];

    return [
        {
            path: `${config.output.utilities}/${config.output.utilitiesFilename}`,
            css,
        },
    ];
}

function addBanner(output: CSSFileOutput): CSSFileOutput {
    return output.map((file) => ({
        ...file,
        css: CSS_BANNER + file.css,
    }));
}

async function generateAllCSS(
    trees: TokenTree[],
    resolved: ResolvedTokens,
    config: InternalConfig,
    modifiers: ModifierMeta[]
): Promise<CSSFileOutput> {
    const output: CSSFileOutput = [];

    const convertedTokens = await processAndConvertTokens(trees, resolved, config);
    const cssVariables = await generateCSSVariables(convertedTokens, config, modifiers);
    const cssVariablesWithBanner = addBanner(cssVariables);
    await writeCSSVariablesToDisk(cssVariablesWithBanner);
    output.push(...cssVariablesWithBanner);

    const utilities = await generateSugarcubeUtilities(convertedTokens, config);
    const utilitiesWithBanner = addBanner(utilities);
    await writeCSSUtilitiesToDisk(utilitiesWithBanner);
    output.push(...utilitiesWithBanner);

    return output;
}

interface GenerateFlags {
    force?: boolean;
    silent?: boolean;
    resolver?: string;
    stylesDir?: string;
    variablesDir?: string;
    variablesFilename?: string;
    utilitiesDir?: string;
    utilitiesFilename?: string;
    fluidMin?: string;
    fluidMax?: string;
    colorFallback?: ColorFallbackStrategy;
}

function buildConfigFromFlags(flags: GenerateFlags): InternalConfig {
    let fluidConfig: FluidConfig | undefined;
    if (flags.fluidMin || flags.fluidMax) {
        fluidConfig = {
            min: flags.fluidMin ? Number.parseInt(flags.fluidMin, 10) : 320,
            max: flags.fluidMax ? Number.parseInt(flags.fluidMax, 10) : 1200,
        };
    }

    const userConfig: SugarcubeConfig = {
        resolver: flags.resolver,
        output: {
            cssRoot: flags.stylesDir,
            variables: flags.variablesDir,
            variablesFilename: flags.variablesFilename,
            utilities: flags.utilitiesDir,
            utilitiesFilename: flags.utilitiesFilename,
        },
        transforms: {
            fluid: fluidConfig,
            colorFallbackStrategy: flags.colorFallback,
        },
    };

    return fillDefaults(userConfig);
}

function mergeConfigWithFlags(config: InternalConfig, flags: GenerateFlags): InternalConfig {
    const fluid: FluidConfig = {
        min: flags.fluidMin ? Number.parseInt(flags.fluidMin, 10) : config.transforms.fluid.min,
        max: flags.fluidMax ? Number.parseInt(flags.fluidMax, 10) : config.transforms.fluid.max,
    };

    return {
        ...config,
        resolver: flags.resolver ?? config.resolver,
        transforms: {
            fluid,
            colorFallbackStrategy: flags.colorFallback ?? config.transforms.colorFallbackStrategy,
        },
        output: {
            ...config.output,
            cssRoot: flags.stylesDir ?? config.output.cssRoot,
            variables: flags.variablesDir ?? config.output.variables,
            variablesFilename: flags.variablesFilename ?? config.output.variablesFilename,
            utilities: flags.utilitiesDir ?? config.output.utilities,
            utilitiesFilename: flags.utilitiesFilename ?? config.output.utilitiesFilename,
        },
    };
}

function hasRelevantFlags(flags: GenerateFlags): boolean {
    return !!(
        flags.resolver ||
        flags.stylesDir ||
        flags.variablesDir ||
        flags.variablesFilename ||
        flags.utilitiesDir ||
        flags.utilitiesFilename ||
        flags.fluidMin ||
        flags.fluidMax ||
        flags.colorFallback
    );
}

function validateFlags(flags: GenerateFlags): void {
    if (flags.colorFallback && !["native", "polyfill"].includes(flags.colorFallback)) {
        throw new CLIError(
            `Invalid --color-fallback value: "${flags.colorFallback}". Must be "native" or "polyfill".`
        );
    }

    if (flags.fluidMin) {
        const min = Number.parseInt(flags.fluidMin, 10);
        if (Number.isNaN(min) || min <= 0) {
            throw new CLIError(
                `Invalid --fluid-min value: "${flags.fluidMin}". Must be a positive number.`
            );
        }
    }

    if (flags.fluidMax) {
        const max = Number.parseInt(flags.fluidMax, 10);
        if (Number.isNaN(max) || max <= 0) {
            throw new CLIError(
                `Invalid --fluid-max value: "${flags.fluidMax}". Must be a positive number.`
            );
        }
    }
}

async function resolveConfig(options: GenerateFlags): Promise<InternalConfig> {
    if (configFileExists()) {
        const { config: loadedConfig } = await loadInternalConfig();
        return mergeConfigWithFlags(loadedConfig, options);
    }

    // Note: We do our own discovery here instead of using loadInternalConfig's fallback
    // because generate needs special flag-merging logic that loadInternalConfig doesn't handle.
    const discovery = await findResolverDocument(process.cwd());

    if (discovery.found === "multiple") {
        throw new CLIError(ERROR_MESSAGES.GENERATE_MULTIPLE_RESOLVERS_NO_CONFIG(discovery.paths));
    }

    const resolverPath =
        options.resolver ?? (discovery.found === "one" ? discovery.path : undefined);

    if (resolverPath || hasRelevantFlags(options)) {
        return buildConfigFromFlags({
            ...options,
            resolver: resolverPath,
        });
    }

    throw new CLIError(ERROR_MESSAGES.GENERATE_NO_CONFIG_OR_RESOLVER());
}

export const generate = new Command()
    .name("generate")
    .description("Generate CSS from your design tokens")
    .option("--force", "Skip overwrite confirmation")
    .option("-s, --silent", "Suppress logs and prompts")
    .option("--resolver <path>", "Path to token resolver file (.resolver.json)")
    .option("--styles-dir <dir>", "CSS output directory (default: 'src/styles')")
    .option(
        "--variables-dir <dir>",
        "Token variables output directory (default: 'src/styles/global')"
    )
    .option(
        "--variables-filename <name>",
        "Token variables filename (default: 'tokens.variables.gen.css')"
    )
    .option("--utilities-dir <dir>", "Utilities output directory (default: 'src/styles/utilities')")
    .option("--utilities-filename <name>", "Utilities filename (default: 'utilities.gen.css')")
    .option("--fluid-min <number>", "Minimum viewport width for fluid scaling (default: 320)")
    .option("--fluid-max <number>", "Maximum viewport width for fluid scaling (default: 1200)")
    .option(
        "--color-fallback <strategy>",
        "Color fallback strategy: 'native' or 'polyfill' (default: native)"
    )
    .action(async (options: GenerateFlags) => {
        try {
            if (!options.silent) {
                intro(label("Generate CSS"));
            }

            validateFlags(options);

            // Check if Vite plugin is installed and warn/exit
            if (isPackageInstalled("@sugarcube-sh/vite")) {
                throw new CLIError(
                    "Sugarcube vite plugin detected. When using the plugin, CSS is generated automatically during your build process. Remove the plugin to use CLI generation instead."
                );
            }

            const finalConfig = await resolveConfig(options);

            const { trees, resolved, modifiers } = await loadAndResolveTokensForCLI(finalConfig);
            const output = await generateAllCSS(trees, resolved, finalConfig, modifiers);

            if (!options.silent) {
                const allFiles = output.map((f) => f.path);
                const uniqueFiles = [...new Set(allFiles)];
                const relativePaths = uniqueFiles.map((file) => relative(process.cwd(), file));

                const tasks = relativePaths.map((file) => ({
                    pending: `Write ${file}`,
                    start: `Writing ${file}`,
                    end: `Wrote ${file}`,
                    while: async () => {},
                }));

                await log.tasks(tasks, {
                    spacing: 1,
                    minDurationMs: 0,
                    successPauseMs: 100,
                    successMessage: "ðŸŽ‰ Files written!",
                });

                log.space(1);
                outro(color.green("CSS generated successfully."));
            }
        } catch (error) {
            handleError(error);
        }
    });
