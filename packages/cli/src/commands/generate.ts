import {
    type CSSFileOutput,
    clearMatchCache,
    convertConfigToUnoRules,
    generateCSSVariables,
    processAndConvertTokens,
    writeCSSUtilitiesToDisk,
    writeCSSVariablesToDisk,
} from "@sugarcube-sh/core";
import type {
    InternalConfig,
    ModifierMeta,
    NormalizedConvertedTokens,
    ResolvedTokens,
    TokenTree,
} from "@sugarcube-sh/core";
import { configFileExists, loadInternalConfig } from "@sugarcube-sh/core";
import { type UserConfig, createGenerator } from "@unocss/core";
import { Command } from "commander";
import { relative } from "pathe";
import color from "picocolors";
import packageJson from "../../package.json" with { type: "json" };
import { type GenerateFlags, resolveConfig, validateFlags } from "../config/generate.js";
import { isPackageInstalled } from "../detection/is-package-installed.js";
import { loadAndResolveTokensForCLI } from "../pipelines/load-and-resolve-for-cli.js";
import { intro, label, outro } from "../prompts/common.js";
import { log } from "../prompts/log.js";
import { getMarkupFiles, readMarkupSources } from "../scanning/markup.js";
import { CLIError } from "../types/index.js";
import { handleError } from "../utils/handle-error.js";
import { startWatcher } from "../watch/watcher.js";
import { validateFilename } from "../validation/flags.js";

const CSS_BANNER = `/* Generated by @sugarcube-sh/cli v${packageJson.version} */\n\n`;

function formatOutputPaths(output: CSSFileOutput): string[] {
    const paths = output.map((f) => f.path);
    const unique = [...new Set(paths)];
    return unique.map((file) => relative(process.cwd(), file));
}

function addBanner(output: CSSFileOutput): CSSFileOutput {
    return output.map((file) => ({ ...file, css: CSS_BANNER + file.css }));
}

export async function generateSugarcubeUtilities(
    tokens: NormalizedConvertedTokens,
    config: InternalConfig
): Promise<CSSFileOutput> {
    if (!config.utilities || Object.keys(config.utilities).length === 0) {
        return [];
    }

    const sugarcubePreset = {
        name: "sugarcube",
        rules: convertConfigToUnoRules(config.utilities, tokens),
        preflights: [],
    };

    const generatorOptions: UserConfig = {
        presets: [sugarcubePreset],
    };

    const generator = await createGenerator(generatorOptions);

    const files = await getMarkupFiles();
    if (files.length === 0) return [];

    const sources = await readMarkupSources(files);
    const combinedSource = sources.join("\n");

    const { css } = await generator.generate(combinedSource, { preflights: false });
    if (!css?.trim()) return [];

    return [
        {
            path: `${config.output.utilities}/${config.output.utilitiesFilename}`,
            css,
        },
    ];
}

function addBanner(output: CSSFileOutput): CSSFileOutput {
    return output.map((file) => ({
        ...file,
        css: CSS_BANNER + file.css,
    }));
}

function wrapInLayer(output: CSSFileOutput, layerName: string): CSSFileOutput {
    return output.map((file) => {
        // Need extra formatting for @layer blocks
        const indentedCss = file.css
            .split("\n")
            .map((line) => (line.trim() ? `    ${line}` : line))
            .join("\n");
        return {
            ...file,
            css: `@layer ${layerName} {\n${indentedCss}}\n`,
        };
    });
}

async function generateAllCSS(
    trees: TokenTree[],
    resolved: ResolvedTokens,
    config: InternalConfig,
    modifiers: ModifierMeta[]
): Promise<CSSFileOutput> {
    const output: CSSFileOutput = [];
    const layersConfig = config.output.layers;

    const convertedTokens = await processAndConvertTokens(trees, resolved, config);

    let cssVariables = await generateCSSVariables(convertedTokens, config, modifiers);
    if (layersConfig) {
        cssVariables = wrapInLayer(cssVariables, layersConfig.variables);
    }
    const cssVariablesWithBanner = addBanner(cssVariables);
    await writeCSSVariablesToDisk(cssVariablesWithBanner);
    output.push(...cssVariablesWithBanner);

    let utilities = await generateSugarcubeUtilities(convertedTokens, config);
    if (layersConfig) {
        utilities = wrapInLayer(utilities, layersConfig.utilities);
    }
    const utilitiesWithBanner = addBanner(utilities);
    await writeCSSUtilitiesToDisk(utilitiesWithBanner);
    output.push(...utilitiesWithBanner);

    return output;
}

async function runGeneration(config: InternalConfig): Promise<CSSFileOutput> {
    clearMatchCache();
    const { trees, resolved, modifiers } = await loadAndResolveTokensForCLI(config);
    return generateAllCSS(trees, resolved, config, modifiers);
}

async function logOneTimeResult(relativePaths: string[]): Promise<void> {
    const tasks = relativePaths.map((file) => ({
        pending: `Write ${file}`,
        start: `Writing ${file}`,
        end: `Wrote ${file}`,
        while: async () => {},
    }));
    await log.tasks(tasks, {
        spacing: 1,
        minDurationMs: 0,
        successPauseMs: 100,
        successMessage: "ðŸŽ‰ Files written!",
    });
    log.space(1);
    outro(color.green("CSS generated successfully."));
}

async function runOneTimeGeneration(config: InternalConfig, options: GenerateFlags): Promise<void> {
    const output = await runGeneration(config);

    if (!options.silent) {
        await logOneTimeResult(formatOutputPaths(output));
    }
}

async function runWatchMode(config: InternalConfig, _options: GenerateFlags): Promise<void> {
    const prefix = color.cyan("[sugarcube]");

    const startTime = performance.now();
    await runGeneration(config);
    const durationMs = Math.round(performance.now() - startTime);
    console.log(`${prefix} Generated in ${durationMs}ms`);

    const watcher = await startWatcher(config, {
        onRegenerate: async (changedPath: string) => {
            const regenStart = performance.now();
            const regenOutput = await runGeneration(config);
            const regenDurationMs = Math.round(performance.now() - regenStart);

            const changedFile = changedPath.split("/").pop() ?? changedPath;
            const outputFiles = formatOutputPaths(regenOutput);
            console.log(
                `${prefix} ${color.dim(changedFile)} â†’ ${outputFiles.join(", ")} ${color.dim(`(${regenDurationMs}ms)`)}`
            );
        },
        onError: (error: Error) => {
            console.log(`${color.red("[sugarcube]")} ${error.message}`);
        },
        onReady: (tokenFileCount: number) => {
            console.log(
                `${prefix} Watching ${tokenFileCount} token file${tokenFileCount === 1 ? "" : "s"} + markup files...`
            );
        },
    });

    process.on("SIGINT", async () => {
        await watcher.close();
        console.log(`${prefix} Watch mode stopped.`);
        process.exit(0);
    });

    await new Promise(() => {});
}

export const generate = new Command()
    .name("generate")
    .description("Generate CSS from your design tokens")
    .option("--force", "Skip overwrite confirmation")
    .option("-s, --silent", "Suppress logs and prompts")
    .option("-w, --watch", "Watch for changes and regenerate automatically")
    .option("--resolver <path>", "Path to token resolver file (.resolver.json)")
    .option("--styles-dir <dir>", "CSS output directory (default: 'src/styles')")
    .option(
        "--variables-dir <dir>",
        "Token variables output directory (default: 'src/styles/global')"
    )
    .option(
        "--variables-filename <name>",
        "Token variables filename (default: 'tokens.variables.gen.css')"
    )
    .option("--utilities-dir <dir>", "Utilities output directory (default: 'src/styles/utilities')")
    .option("--utilities-filename <name>", "Utilities filename (default: 'utilities.gen.css')")
    .option("--fluid-min <number>", "Minimum viewport width for fluid scaling (default: 320)")
    .option("--fluid-max <number>", "Maximum viewport width for fluid scaling (default: 1200)")
    .option(
        "--color-fallback <strategy>",
        "Color fallback strategy: 'native' or 'polyfill' (default: native)"
    )
    .action(async (options: GenerateFlags) => {
        try {
            if (!options.silent && !options.watch) {
                intro(label("Generate CSS"));
            }

            validateFlags(options);

            if (isPackageInstalled("@sugarcube-sh/vite")) {
                throw new CLIError(
                    "Sugarcube vite plugin detected. When using the plugin, CSS is generated automatically during your build process. Remove the plugin to use CLI generation instead."
                );
            }

            const finalConfig = await resolveConfig(options);

            const run = options.watch ? runWatchMode : runOneTimeGeneration;
            await run(finalConfig, options);
        } catch (error) {
            handleError(error);
        }
    });
