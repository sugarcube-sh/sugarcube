import {
    type CSSFileOutput,
    type ColorFallbackStrategy,
    type FluidConfig,
    type SugarcubeConfig,
    clearMatchCache,
    configFileExists,
    convertConfigToUnoRules,
    fillDefaults,
    findResolverDocument,
    generateCSSVariables,
    loadInternalConfig,
    processAndConvertTokens,
    writeCSSUtilitiesToDisk,
    writeCSSVariablesToDisk,
} from "@sugarcube-sh/core";
import type {
    InternalConfig,
    ModifierMeta,
    NormalizedConvertedTokens,
    ResolvedTokens,
    TokenTree,
} from "@sugarcube-sh/core";
import { type UserConfig, createGenerator } from "@unocss/core";
import { Command } from "commander";
import { relative } from "pathe";
import color from "picocolors";
import packageJson from "../../package.json" with { type: "json" };
import { ERROR_MESSAGES } from "../constants/error-messages.js";
import { loadAndResolveTokensForCLI } from "../pipelines/load-and-resolve-for-cli.js";
import { intro, label, outro } from "../prompts/common.js";
import { log } from "../prompts/log.js";
import { getMarkupFiles, readMarkupSources } from "../scanning/markup.js";
import { CLIError } from "../types/index.js";
import { handleError } from "../utils/handle-error.js";
import { validateFilename } from "../validation/flags.js";
import { startWatcher } from "../watch/watcher.js";

const CSS_BANNER = `/* Generated by @sugarcube-sh/cli v${packageJson.version} */\n\n`;

interface GenerateFlags {
    force?: boolean;
    silent?: boolean;
    watch?: boolean;
    resolver?: string;
    stylesDir?: string;
    variablesDir?: string;
    variablesFilename?: string;
    utilitiesDir?: string;
    utilitiesFilename?: string;
    fluidMin?: string;
    fluidMax?: string;
    colorFallback?: ColorFallbackStrategy;
}

function parseFluidValue(value: string | undefined, fallback: number): number {
    return value ? Number.parseInt(value, 10) : fallback;
}

function buildFluidConfig(flags: GenerateFlags): FluidConfig | undefined {
    if (!flags.fluidMin && !flags.fluidMax) return undefined;
    return {
        min: parseFluidValue(flags.fluidMin, 320),
        max: parseFluidValue(flags.fluidMax, 1200),
    };
}

function buildConfigFromFlags(flags: GenerateFlags): InternalConfig {
    const userConfig: SugarcubeConfig = {
        resolver: flags.resolver,
        output: {
            cssRoot: flags.stylesDir,
            variables: flags.variablesDir,
            variablesFilename: flags.variablesFilename,
            utilities: flags.utilitiesDir,
            utilitiesFilename: flags.utilitiesFilename,
        },
        transforms: {
            fluid: buildFluidConfig(flags),
            colorFallbackStrategy: flags.colorFallback,
        },
    };

    return fillDefaults(userConfig);
}

function mergeConfigWithFlags(config: InternalConfig, flags: GenerateFlags): InternalConfig {
    return {
        ...config,
        resolver: flags.resolver ?? config.resolver,
        transforms: {
            fluid: {
                min: parseFluidValue(flags.fluidMin, config.transforms.fluid.min),
                max: parseFluidValue(flags.fluidMax, config.transforms.fluid.max),
            },
            colorFallbackStrategy: flags.colorFallback ?? config.transforms.colorFallbackStrategy,
        },
        output: {
            ...config.output,
            cssRoot: flags.stylesDir ?? config.output.cssRoot,
            variables: flags.variablesDir ?? config.output.variables,
            variablesFilename: flags.variablesFilename ?? config.output.variablesFilename,
            utilities: flags.utilitiesDir ?? config.output.utilities,
            utilitiesFilename: flags.utilitiesFilename ?? config.output.utilitiesFilename,
        },
    };
}

function hasConfigFlags(flags: GenerateFlags): boolean {
    return !!(
        flags.resolver ||
        flags.stylesDir ||
        flags.variablesDir ||
        flags.variablesFilename ||
        flags.utilitiesDir ||
        flags.utilitiesFilename ||
        flags.fluidMin ||
        flags.fluidMax ||
        flags.colorFallback
    );
}

async function resolveConfig(options: GenerateFlags): Promise<InternalConfig> {
    if (configFileExists()) {
        const { config: loadedConfig } = await loadInternalConfig();
        return mergeConfigWithFlags(loadedConfig, options);
    }

    // Note: We do our own discovery here instead of using loadInternalConfig's fallback
    // because generate needs special flag-merging logic that loadInternalConfig doesn't handle.
    const discovery = await findResolverDocument(process.cwd());

    if (discovery.found === "multiple") {
        throw new CLIError(ERROR_MESSAGES.GENERATE_MULTIPLE_RESOLVERS_NO_CONFIG(discovery.paths));
    }

    const resolverPath =
        options.resolver ?? (discovery.found === "one" ? discovery.path : undefined);

    if (resolverPath || hasConfigFlags(options)) {
        return buildConfigFromFlags({ ...options, resolver: resolverPath });
    }

    throw new CLIError(ERROR_MESSAGES.GENERATE_NO_CONFIG_OR_RESOLVER());
}

function formatOutputPaths(output: CSSFileOutput): string[] {
    const paths = output.map((f) => f.path);
    const unique = [...new Set(paths)];
    return unique.map((file) => relative(process.cwd(), file));
}

async function generateSugarcubeUtilities(
    tokens: NormalizedConvertedTokens,
    config: InternalConfig
): Promise<CSSFileOutput> {
    if (!config.utilities || Object.keys(config.utilities).length === 0) {
        return [];
    }

    const sugarcubePreset = {
        name: "sugarcube",
        rules: convertConfigToUnoRules(config.utilities, tokens),
        preflights: [],
    };

    const generatorOptions: UserConfig = {
        presets: [sugarcubePreset],
    };

    const generator = await createGenerator(generatorOptions);

    const files = await getMarkupFiles();
    if (files.length === 0) return [];

    const sources = await readMarkupSources(files);
    const combinedSource = sources.join("\n");

    const { css } = await generator.generate(combinedSource, { preflights: false });
    if (!css?.trim()) return [];

    return [
        {
            path: `${config.output.utilities}/${config.output.utilitiesFilename}`,
            css,
        },
    ];
}

function addBanner(output: CSSFileOutput): CSSFileOutput {
    return output.map((file) => ({
        ...file,
        css: CSS_BANNER + file.css,
    }));
}

function wrapInLayer(output: CSSFileOutput, layerName: string): CSSFileOutput {
    return output.map((file) => {
        // Need extra formatting for @layer blocks
        const indentedCss = file.css
            .split("\n")
            .map((line) => (line.trim() ? `    ${line}` : line))
            .join("\n");
        return {
            ...file,
            css: `@layer ${layerName} {\n${indentedCss}}\n`,
        };
    });
}

async function generateAllCSS(
    trees: TokenTree[],
    resolved: ResolvedTokens,
    config: InternalConfig,
    modifiers: ModifierMeta[]
): Promise<CSSFileOutput> {
    const output: CSSFileOutput = [];
    const layersConfig = config.output.layers;

    const convertedTokens = await processAndConvertTokens(trees, resolved, config);

    let cssVariables = await generateCSSVariables(convertedTokens, config, modifiers);
    if (layersConfig) {
        cssVariables = wrapInLayer(cssVariables, layersConfig.variables);
    }
    const cssVariablesWithBanner = addBanner(cssVariables);
    await writeCSSVariablesToDisk(cssVariablesWithBanner);
    output.push(...cssVariablesWithBanner);

    let utilities = await generateSugarcubeUtilities(convertedTokens, config);
    if (layersConfig) {
        utilities = wrapInLayer(utilities, layersConfig.utilities);
    }
    const utilitiesWithBanner = addBanner(utilities);
    await writeCSSUtilitiesToDisk(utilitiesWithBanner);
    output.push(...utilitiesWithBanner);

    return output;
}

async function runGeneration(config: InternalConfig): Promise<CSSFileOutput> {
    clearMatchCache();
    const { trees, resolved, modifiers } = await loadAndResolveTokensForCLI(config);
    return generateAllCSS(trees, resolved, config, modifiers);
}

async function logOneTimeResult(relativePaths: string[]): Promise<void> {
    const tasks = relativePaths.map((file) => ({
        pending: `Write ${file}`,
        start: `Writing ${file}`,
        end: `Wrote ${file}`,
        while: async () => {},
    }));
    await log.tasks(tasks, {
        spacing: 1,
        minDurationMs: 0,
        successPauseMs: 100,
        successMessage: "ðŸŽ‰ Files written!",
    });
    log.space(1);
    outro(color.green("CSS generated successfully."));
}

async function runOneTimeGeneration(config: InternalConfig, options: GenerateFlags): Promise<void> {
    const output = await runGeneration(config);

    if (!options.silent) {
        await logOneTimeResult(formatOutputPaths(output));
    }
}

async function runWatchMode(config: InternalConfig, _options: GenerateFlags): Promise<void> {
    const prefix = color.cyan("[sugarcube]");

    const startTime = performance.now();
    await runGeneration(config);
    const durationMs = Math.round(performance.now() - startTime);
    console.log(`${prefix} Generated in ${durationMs}ms`);

    const watcher = await startWatcher(config, {
        onRegenerate: async (changedPath: string) => {
            const regenStart = performance.now();
            const regenOutput = await runGeneration(config);
            const regenDurationMs = Math.round(performance.now() - regenStart);

            const changedFile = changedPath.split("/").pop() ?? changedPath;
            const outputFiles = formatOutputPaths(regenOutput);
            console.log(
                `${prefix} ${color.dim(changedFile)} â†’ ${outputFiles.join(", ")} ${color.dim(`(${regenDurationMs}ms)`)}`
            );
        },
        onError: (error: Error) => {
            console.log(`${color.red("[sugarcube]")} ${error.message}`);
        },
        onReady: (tokenFileCount: number) => {
            console.log(
                `${prefix} Watching ${tokenFileCount} token file${tokenFileCount === 1 ? "" : "s"} + markup files...`
            );
        },
    });

    process.on("SIGINT", async () => {
        await watcher.close();
        console.log(`${prefix} Watch mode stopped.`);
        process.exit(0);
    });

    await new Promise(() => {});
}

export const generate = new Command()
    .name("generate")
    .description("Generate CSS from your design tokens")
    .option("--force", "Skip overwrite confirmation")
    .option("-s, --silent", "Suppress logs and prompts")
    .option("-w, --watch", "Watch for changes and regenerate automatically")
    .option("--resolver <path>", "Path to token resolver file (.resolver.json)")
    .option("--styles-dir <dir>", "CSS output directory (default: 'src/styles')")
    .option(
        "--variables-dir <dir>",
        "Token variables output directory (default: 'src/styles/global')"
    )
    .option(
        "--variables-filename <name>",
        "Token variables filename (default: 'tokens.variables.gen.css')"
    )
    .option("--utilities-dir <dir>", "Utilities output directory (default: 'src/styles/utilities')")
    .option("--utilities-filename <name>", "Utilities filename (default: 'utilities.gen.css')")
    .option("--fluid-min <number>", "Minimum viewport width for fluid scaling (default: 320)")
    .option("--fluid-max <number>", "Maximum viewport width for fluid scaling (default: 1200)")
    .option(
        "--color-fallback <strategy>",
        "Color fallback strategy: 'native' or 'polyfill' (default: native)"
    )
    .action(async (options: GenerateFlags) => {
        try {
            if (!options.silent && !options.watch) {
                intro(label("Generate CSS"));
            }

            validateFilename(options.variablesFilename, "--variables-filename");
            validateFilename(options.utilitiesFilename, "--utilities-filename");

            const finalConfig = await resolveConfig(options);

            const run = options.watch ? runWatchMode : runOneTimeGeneration;
            await run(finalConfig, options);
        } catch (error) {
            handleError(error);
        }
    });
